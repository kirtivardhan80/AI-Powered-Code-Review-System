import os
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv
from pygments.lexers import guess_lexer
from pygments.util import ClassNotFound
import re

# 1. Load API Key
load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("⚠️ GEMINI_API_KEY not found. Add it in your .env file.")

# 2. Initialize Gemini (Pro Model)
llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-pro",   # Gemini 2.5 Pro
    google_api_key=api_key,
    temperature=0.2
)

print("\n🔹 Gemini Universal Code Reviewer (Prototype)")
print("Paste your code snippet below (any language).")
print("👉 Press ENTER twice when done:\n")

# 3. Collect multi-line snippet
lines = []
while True:
    try:
        line = input()
        if line.strip() == "":  # blank line = end input
            break
        lines.append(line)
    except EOFError:
        break

code_snippet = "\n".join(lines)
if not code_snippet.strip():
    print("⚠️ No code snippet entered. Exiting.")
    exit()

# 4. Detect Language using Pygments
def detect_language_pygments(code: str) -> tuple:
    try:
        lexer = guess_lexer(code)
        return lexer.name, 0.85  # Assume 85% confidence for Pygments
    except ClassNotFound:
        return "Unknown", 0.0

pygments_lang, pygments_conf = detect_language_pygments(code_snippet)

# 5. Ask Gemini for language detection
lang_prompt = f"Detect the programming language for the following code:\n\n{code_snippet}\n\nReturn only the language name."
gemini_lang_response = llm.invoke(lang_prompt)
gemini_lang = gemini_lang_response.content.strip()
gemini_conf = 0.9 if gemini_lang.lower() != "unknown" else 0.3

# 6. Choose best language based on confidence
if gemini_conf > pygments_conf:
    final_lang = gemini_lang
    final_conf = gemini_conf
else:
    final_lang = pygments_lang
    final_conf = pygments_conf

print(f"\n📌 Detected Language: {final_lang} (Confidence: {final_conf*100:.1f}%)\n")

# 7. Review Code + Auto-fix
prompt = f"""
You are a code reviewer. The code below is written in **{final_lang}**.

Tasks:
- Identify bugs or errors
- Suggest improvements (style, performance, readability, best practices, security)
- Provide a corrected or optimized version under the section: "Corrected Code"

Code Snippet:
{code_snippet}
"""

response = llm.invoke(prompt)

print("\n===== Gemini Review =====\n")
print(response.content)

# 8. Extract Auto-Fixed Code (if present)
corrected_code_match = re.search(r"(?s)(?<=Corrected Code:).*", response.content)
if corrected_code_match:
    corrected_code = corrected_code_match.group(0).strip()
    if corrected_code:
        # Ask user if they want to save the corrected code
        save_choice = input("\n💾 Do you want to save the corrected code to a file? (y/n): ").lower()
        if save_choice == "y":
            # Decide file extension based on language
            ext_map = {
                "Python": "py", "Java": "java", "C++": "cpp", "C": "c",
                "JavaScript": "js", "TypeScript": "ts", "PHP": "php",
                "Go": "go", "Ruby": "rb", "Kotlin": "kt", "Swift": "swift"
            }
            file_ext = ext_map.get(final_lang, "txt")
            file_name = f"fixed_code.{file_ext}"

            with open(file_name, "w", encoding="utf-8") as f:
                f.write(corrected_code)

            print(f"✅ Corrected code saved as {file_name}")
        else:
            print("✔ Corrected code not saved.")
    else:
        print("⚠️ No corrected code section found in response.")
else:
    print("⚠️ No corrected code detected in Gemini's response.")
